import numpy as np
import timeit
# -*- coding: utf-8 -*-
"""Color Blindness.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19-Dz5qLQ9LXHbC4USO836e0rz6s81aJi

# Assignment 4 : Color Blindness
Adarsh T Shah, MTech (AI),19473
"""

import numpy as np
#To Measure Run time
import timeit

#Read from bwt
file = open("../data/chrX_last_col.txt",'r')
bwt = file.readlines()
file.close()

#Read indices
file = open("../data/chrX_map.txt",'r')
idx = file.readlines()
file.close()

#Read reference
file = open("../data/chrX.fa",'r')
file.readline()
reference = file.readlines()
file.close()

#Generating Milestones
A,C,G,T = np.zeros(shape=len(bwt),dtype=np.int32),np.zeros(shape=len(bwt),dtype=np.int32),np.zeros(shape=len(bwt),dtype=np.int32),np.zeros(shape=len(bwt),dtype=np.int32)

#Count and store A,C,G,T from each 100 length block
for i in range(len(A)):
    A[i]=bwt[i].count('A')
    C[i]=bwt[i].count('C')
    G[i]=bwt[i].count('G')
    T[i]=bwt[i].count('T')

#Generating Ranks in Milestones
for i in range(1,len(A)):
    A[i]=A[i-1]+A[i]
    C[i]=C[i-1]+C[i]
    G[i]=G[i-1]+G[i]
    T[i]=T[i-1]+T[i]

Milestone={'A':A,'C':C,'G':G,'T':T}
def search(read):
    #Initial Band
    Band = [0,Milestone['A'][-1]+Milestone['C'][-1]+Milestone['G'][-1]+Milestone['T'][-1]+1]

    #Searching in reverse for each suffix
    for i in reversed(range(len(read))):        
        #Character C to be searches
        C = read[i]

        #Generating nearest Blocks
        start,sidx = Band[0]//100,Band[0]%100
        end,eidx = Band[1]//100,Band[1]%100

        #Rank of first and last C
        rf1,rf2 = -1,-1
        
        #Searching for first C in Band
        rf1 = Milestone[C][start]-bwt[start][sidx:].count(C)+1

        #Searching for last C in Band
        rf2 = Milestone[C][end]-bwt[end].count(C)+bwt[end][:eidx+1].count(C)

        if rf2<rf1:
            return Band,i+1

        if C=='A':
            Band = [rf1-1,rf2-1]
        elif C=='C':
            Band = [Milestone['A'][-1]+rf1-1,Milestone['A'][-1]+rf2-1]
        elif C=='G':
            Band = [Milestone['A'][-1]+Milestone['C'][-1]+rf1-1,Milestone['A'][-1]+Milestone['C'][-1]+rf2-1]
        elif C=='T':
            Band = [Milestone['A'][-1]+Milestone['C'][-1]+Milestone['G'][-1]+rf1-1, Milestone['A'][-1]+Milestone['C'][-1]+Milestone['G'][-1]+rf2-1]
    return Band,0

#Extract given string starting from given index from reference string
def extract(index,length):

  #Identifying character block and offset
  block = index//100
  start = index%100

  #Storing intermediate result here
  result = ""

  #Extract from first block
  result += reference[block][start:-1]

  #Extract from consecutive blocks
  while len(result)<length:
    block+=1
    result += reference[block][:-1]
  
  #Trimming the extra tail characters
  result = result[:length]

  return result

#Utility function to count mismatches
#Returns True if mismactes <=2
def count_miss(str1,str2):

  mis = 0

  if len(str1)!=len(str2):
    return False
  
  for i in range(len(str1)):
    if str1[i]!=str2[i]:
      mis+=1
    if mis>2:
      return False
  
  return True

#Generate Reverse Complement of a string
def reverseComplement(read:str):
  read = read[::-1]
  result = read.replace('A','t').replace('T','a').replace('C','g').replace('G','c')
  return str.upper(result) 

start = timeit.default_timer()
#Maintain counts for match in each exon of Red and Green genes
RExons = np.zeros(6)
GExons = np.zeros(6)
Exons = np.zeros(6)

#Reading reads
with open("../data/reads",'r') as file:
    for i, read in enumerate(file):
        #Replacing N with A in reads
        if i % 10000 == 0:
           print(i)
           print(RExons)
           print(GExons)
        read = read[:-1].replace('N','A')

        #Reverse Complement of string
        readrevcomp = reverseComplement(read)

        #Indicators that read matches to R and G
        R,G = np.zeros(6),np.zeros(6)

        for read_ in [read,readrevcomp]:
          #Search Operation
          #Shift indicates the position in read where first mismatch occured from right to left
          band,shift = search(read_)

          for i in range(band[0],band[1]+1):
            
            #Adjusting index
            id = int(idx[i])-shift
            
            #Extracting reference string from reference at index id
            ref = extract(id,len(read_))
            
            #Testing if mismatches between read and extracted string is < 2
            if count_miss(ref,read_):
              #Checking Red Gene and storing result for match in each Exon
              if (id>=149249757 and id<=149249868):
                  R[0]=1
              if (id>=149256127 and id<=149256423):
                  R[1]=1
              if (id>=149258412 and id<=149258580):
                  R[2]=1
              if (id>=149260048 and id<=149260213): 
                  R[3]=1
              if (id>=149261768 and id<=149262007): 
                  R[4]=1
              if (id>=149264290 and id<=149264400):
                  R[5]=1

              #Checking Green Gene
              if (id>=149288166 and id<=149288277): 
                  G[0]=1
              if (id>=149293258 and id<=149293554): 
                  G[1]=1
              if (id>=149295542 and id<=149295710):
                  G[2]=1
              if (id>=149297178 and id<=149297343): 
                  G[3]=1
              if (id>=149298898 and id<=149299137): 
                  G[4]=1
              if (id>=149301420 and id<=149301530):
                  G[5]=1

        #Saving the matched result in global result
        for i in range(6):            
          if R[i]==G[i] and R[i]==1:
            RExons[i]+=0.5
            GExons[i] += 0.5
          elif R[i]==1:
            RExons[i]+=1
          elif G[i]==1:
            GExons[i]+=1

    else:
      file.close()

#The final result Count is summation of Exons
print(Exons)
stop = timeit.default_timer()
print('Time: ', stop - start)
print(RExons)
print(GExons)